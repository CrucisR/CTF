from Crypto.Util.number import *

# flag = b'###'
# p = getPrime (128)
# q = getPrime (128)
# r = getPrime (128)
# n = p * q* r
# N = pow(p, 2)+ pow(q, 2)
e = 65537
#enc
# c = pow(bytes_to_long(flag),e,n)
# ср = c%p
# cq = c%q
# cr = c%r
# print (N,n, cp, cq, cr)
N = 174614584514610929431396115941630384895178909723705718836862238095900829966738
n = 25734163146776863423334597563854508025295423350215772176197139108245197394099966778835320485200297366854897680006649
ср = 119835366288961698540579634520960353987
cq = 205217723185958485497338964538298567862
cr = 114342282872579112405953192140116908309

p = 323220892738543152054341271709492856593
q = 264844933898895094781643605097884203033
r = 300620750405215104529267866758584282321

# N = pow(p, 2)+ pow(q, 2)
# print(N)
# 174614584514610929431396115941630384895178909723705718836862238095900829966738

from sympy.ntheory.modular import crt

# 使用中国剩余定理解决模同余方程
# c = crt([p, q, r], [ср, cq, cr])[0]

# print("c =", c)
c = 22566703933316443611993891146068851199903151638817247253667565470192019317534382676677092315283218708147324965904985




from sympy import mod_inverse

# 计算欧拉函数
phi_n = (p - 1) * (q - 1) * (r - 1)

# 计算私钥 d
# d = mod_inverse(e, phi_n)

# print("Private Key (d):", d)

d = inverse(e, phi_n)
print("Private Key (d):", d)


d = 11651583426984907279256107443310722441167664858513978899415278821228963690510088954046538174603685197531931107489793

# m = pow(c,d,n)
# print("m =", m)

# m = 9966997572481264848811933388191940583713155493833205990407647323504663705186233906872934419523662482269964905511764

# mp = pow(ср, 1, p)
# mq = pow(cq, 1, q)
# mr = pow(cr, 1, r)

# m = (mp * q * inverse(q, p) + mq * p * inverse(p, q) + mr * p * q * inverse(q, r)) % N
# print("m =", m)
# # 117932855365106055881753997783940770897821673674995681675910776083380899320811
# flag = long_to_bytes(m)

# decoded_data = flag.decode('gbk')

# print(decoded_data)

# from Crypto.Util.number import long_to_bytes

# def rsa_decrypt(ciphertext, e, n):
#     plaintext = pow(ciphertext, e, n)
#     return plaintext

# 已知的数据

# 解密密文
# plaintext = rsa_decrypt(c, e, n)

# m =  pow(c,e,n)
# print("解密后的明文为:", m)
# 7259155884055966917431346892204610032418349309854159658211791667939294301799237677333821579417117021466380432470877