from Crypto.Util.number import *
from sympy import isprime
from math import gcd, isqrt
import concurrent.futures

# Helper function to find modular inverse
def modinv(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += m0
    return x1

# Task 1: Recover p1 and q1
def recover_p1_q1(n1, pbar):
    def check_p1_candidate(k):
        p1_candidate = k * (2 ** 562) + pbar
        if n1 % p1_candidate == 0:
            q1_candidate = n1 // p1_candidate
            if isprime(q1_candidate):
                return p1_candidate, q1_candidate
        return None

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {executor.submit(check_p1_candidate, k): k for k in range(2 ** (1024 - 562))}
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result is not None:
                return result
    return None, None

# Task 2: Recover p2 and q2
def recover_p2_q2(n2, v, bit_len_q2):
    def check_p2_candidate(r):
        p2_candidate = (v << r)
        if n2 % p2_candidate == 0:
            q2_candidate = n2 // p2_candidate
            if isprime(q2_candidate):
                return p2_candidate, q2_candidate
        return None

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {executor.submit(check_p2_candidate, r): r for r in range(256)}
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result is not None:
                return result
    return None, None

# Provided values for Task 1
pbar = 6163052460653484875222897871157214579695585174891162334492786197049974156163331261890110177547761022234329462136895755353549723084727441669764541927830678787635575660347
n1 = 19768100979643178970980222798514241427847019621885556714371417306890322413841759155705534740675505641218229128272878009360947016811255408216649419289094293346805021206562475574510447819185154841486638959169187323643703056356558087814806552256616914926631924571704104265274285060591175960523777901261693741556173545977822634199184934702888116805044900132944600846083977172319903839498719090224832707054269425475717758130694735545845648524802276601816827231690868680399305987918120731997093606128145918412651346475602662507731815533837986806539546744344871863963959358138574136679183367178701193757836744520971998033489
c1 = 10510704287421598064923207205443434987649107724961840980540099065383493172702132986990919118704302537850501494540050615373207280562745412929077036236441357066745184251162964131411221716516405523828174133408833061619307488453539707753144972451676202156737070312370001177385210347503280219978816663943757370721860107122948144254203283353095695514204913090647256169755811550374583701604668732607639771411216498112107507915894609138425855355533539795314642466254410740876956635185133792747649115488884248829618454725387044380868005976380847185801851017281198702986435528487365976639275461888993167549955183114098585027025
e = 65537

# Task 2: Provided values
v = 21811641343255983500381828224929413459990162361850958125383974234884106307873322539765955554263002248428935202562895865347202800040026789414846833621961327
n2 = 80770367920827999366561124806858072244868246530328531406042193928182500146180018588600031672448257079863184223921795979757349028463789221446358339745547043692750222588739400567530737810813398459822168705125460502585755974278493854596146452325614299258779463923215509726313171542464349985581821617990647624183
c2 = 56343782366102833380745295389213485175221491538534848704702375927613840775732575944761885136116674144349169787377556123570123828334442175961899563259853689100791589574300729801115267366815647384965461858231633069473434409311760232006811495812507586049512050751885791314256954159905987409748845237122699825479

# Task 1: Recover p1 and q1
p1, q1 = recover_p1_q1(n1, pbar)
if not p1 or not q1:
    raise ValueError("Failed to factorize n1 with given pbar")

# Compute phi(n1) and d1
phi_n1 = (p1 - 1) * (q1 - 1)
d1 = modinv(e, phi_n1)
m1 = pow(c1, d1, n1)
m1_bytes = long_to_bytes(m1)

# Task 2: Recover p2 and q2
bit_len_q2 = 256
p2, q2 = recover_p2_q2(n2, v, bit_len_q2)
if not p2 or not q2:
    raise ValueError("Failed to factorize n2 with given v")

# Compute phi(n2) and d2
phi_n2 = (p2 - 1) * (q2 - 1)
d2 = modinv(e, phi_n2)
m2 = pow(c2, d2, n2)
m2_bytes = long_to_bytes(m2)

# Combine the results to get the flag
flag = m1_bytes + m2_bytes
print(flag)
